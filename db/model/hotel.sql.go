// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: hotel.sql

package model

import (
	"context"
	"time"

	"github.com/lib/pq"
	"github.com/shopspring/decimal"
)

const addRoomDate = `-- name: AddRoomDate :exec
INSERT INTO hotel_room_date (order_id, hotel_id, room_item_id, date, status, created_at, updated_at)
VALUES (
           unnest($1::BIGINT[]),
           unnest($2::BIGINT[]),
           unnest($3::BIGINT[]),
           unnest($4::DATE[]),
           unnest($5::SMALLINT[]),
           unnest($6::TIMESTAMP[]),
           unnest($7::TIMESTAMP[])
       )
`

type AddRoomDateParams struct {
	OrderID    []int64     `json:"order_id"`
	HotelID    []int64     `json:"hotel_id"`
	RoomItemID []int64     `json:"room_item_id"`
	Date       []time.Time `json:"date"`
	Status     []int16     `json:"status"`
	CreatedAt  []time.Time `json:"created_at"`
	UpdatedAt  []time.Time `json:"updated_at"`
}

func (q *Queries) AddRoomDate(ctx context.Context, arg AddRoomDateParams) error {
	_, err := q.db.ExecContext(ctx, addRoomDate,
		pq.Array(arg.OrderID),
		pq.Array(arg.HotelID),
		pq.Array(arg.RoomItemID),
		pq.Array(arg.Date),
		pq.Array(arg.Status),
		pq.Array(arg.CreatedAt),
		pq.Array(arg.UpdatedAt),
	)
	return err
}

const findAvailableRoomItems = `-- name: FindAvailableRoomItems :many
SELECT DISTINCT ri.id
FROM hotel_room_item ri
WHERE ri.id = ANY($2::BIGINT[])
  AND NOT EXISTS (
    SELECT 1
    FROM hotel_room_date hrd
    WHERE hrd.room_item_id = ri.id
      AND hrd.date >= $3::DATE
        AND hrd.date < $4::DATE
) LIMIT $1
`

type FindAvailableRoomItemsParams struct {
	Limit       int32     `json:"limit"`
	RoomItemIds []int64   `json:"room_item_ids"`
	StartDate   time.Time `json:"start_date"`
	EndDate     time.Time `json:"end_date"`
}

func (q *Queries) FindAvailableRoomItems(ctx context.Context, arg FindAvailableRoomItemsParams) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, findAvailableRoomItems,
		arg.Limit,
		pq.Array(arg.RoomItemIds),
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findRoomItemIDsByRoomTypeID = `-- name: FindRoomItemIDsByRoomTypeID :many
SELECT id
FROM hotel_room_item
WHERE hotel_id = $1
  AND room_type_id = $2
  AND status = 1
`

type FindRoomItemIDsByRoomTypeIDParams struct {
	HotelID    int64 `json:"hotel_id"`
	RoomTypeID int64 `json:"room_type_id"`
}

func (q *Queries) FindRoomItemIDsByRoomTypeID(ctx context.Context, arg FindRoomItemIDsByRoomTypeIDParams) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, findRoomItemIDsByRoomTypeID, arg.HotelID, arg.RoomTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findSkuByID = `-- name: FindSkuByID :one
SELECT id, hotel_id, room_type_id, sales_price, refund_status, merchant_id, created_at, updated_at
FROM hotel_sku
WHERE id = $1
`

type FindSkuByIDRow struct {
	ID           int64           `json:"id"`
	HotelID      int64           `json:"hotel_id"`
	RoomTypeID   int64           `json:"room_type_id"`
	SalesPrice   decimal.Decimal `json:"sales_price"`
	RefundStatus bool            `json:"refund_status"`
	MerchantID   int64           `json:"merchant_id"`
	CreatedAt    time.Time       `json:"created_at"`
	UpdatedAt    time.Time       `json:"updated_at"`
}

func (q *Queries) FindSkuByID(ctx context.Context, id int64) (FindSkuByIDRow, error) {
	row := q.db.QueryRowContext(ctx, findSkuByID, id)
	var i FindSkuByIDRow
	err := row.Scan(
		&i.ID,
		&i.HotelID,
		&i.RoomTypeID,
		&i.SalesPrice,
		&i.RefundStatus,
		&i.MerchantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPrice = `-- name: GetPrice :many
SELECT id, hotel_id, sku_id, room_type_id, date,
    market_price, sale_price, ticket_price, ticket_status, created_at, updated_at
FROM hotel_sku_day_price
WHERE
    sku_id = $1
    AND date >= $2::DATE AND date < $3::DATE
ORDER BY date
`

type GetPriceParams struct {
	SkuID     int64     `json:"sku_id"`
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
}

func (q *Queries) GetPrice(ctx context.Context, arg GetPriceParams) ([]HotelSkuDayPrice, error) {
	rows, err := q.db.QueryContext(ctx, getPrice, arg.SkuID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HotelSkuDayPrice
	for rows.Next() {
		var i HotelSkuDayPrice
		if err := rows.Scan(
			&i.ID,
			&i.HotelID,
			&i.SkuID,
			&i.RoomTypeID,
			&i.Date,
			&i.MarketPrice,
			&i.SalePrice,
			&i.TicketPrice,
			&i.TicketStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
