// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: product.sql

package model

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/shopspring/decimal"
)

const decreaseSkuStock = `-- name: DecreaseSkuStock :exec
UPDATE product_sku_stock
SET stock = stock - $2
WHERE sku_id = $1 AND stock >= $2
`

type DecreaseSkuStockParams struct {
	SkuID int32 `json:"sku_id"`
	Stock int32 `json:"stock"`
}

func (q *Queries) DecreaseSkuStock(ctx context.Context, arg DecreaseSkuStockParams) error {
	_, err := q.db.ExecContext(ctx, decreaseSkuStock, arg.SkuID, arg.Stock)
	return err
}

const getProductWithSkus = `-- name: GetProductWithSkus :one
SELECT
    p.id AS product_id,
    p.name AS product_name,
    p.description,
    p.price AS product_price,
    p.images AS product_images,
    p.created_at AS product_created_at,
    json_agg(
            json_build_object(
                    'id', s.id,
                    'name', s.name,
                    'specs', s.specs,
                    'price', s.price,
                    'images', s.images,
                    'created_at', s.created_at,
                    'stock', st.stock
            )
    ) AS skus
FROM product AS p
         LEFT JOIN product_sku AS s ON p.id = s.product_id
         LEFT JOIN product_sku_stock AS st ON s.id = st.sku_id
WHERE p.id = $1
GROUP BY p.id
`

type GetProductWithSkusRow struct {
	ProductID        int64           `json:"product_id"`
	ProductName      string          `json:"product_name"`
	Description      sql.NullString  `json:"description"`
	ProductPrice     decimal.Decimal `json:"product_price"`
	ProductImages    sql.NullString  `json:"product_images"`
	ProductCreatedAt time.Time       `json:"product_created_at"`
	Skus             json.RawMessage `json:"skus"`
}

func (q *Queries) GetProductWithSkus(ctx context.Context, id int64) (GetProductWithSkusRow, error) {
	row := q.db.QueryRowContext(ctx, getProductWithSkus, id)
	var i GetProductWithSkusRow
	err := row.Scan(
		&i.ProductID,
		&i.ProductName,
		&i.Description,
		&i.ProductPrice,
		&i.ProductImages,
		&i.ProductCreatedAt,
		&i.Skus,
	)
	return i, err
}

const listProducts = `-- name: ListProducts :many
SELECT
    p.id,
    p.name,
    p.description,
    MIN(s.price) AS price,
    p.images,
    p.created_at
FROM product AS p
         JOIN product_sku s ON p.id = s.product_id
GROUP BY p.id
ORDER BY p.created_at DESC
    LIMIT $2 OFFSET $1
`

type ListProductsParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type ListProductsRow struct {
	ID          int64          `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	Price       interface{}    `json:"price"`
	Images      sql.NullString `json:"images"`
	CreatedAt   time.Time      `json:"created_at"`
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]ListProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, listProducts, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsRow
	for rows.Next() {
		var i ListProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Images,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSkuStock = `-- name: UpdateSkuStock :exec
UPDATE product_sku_stock
SET stock = $2
WHERE sku_id = $1
`

type UpdateSkuStockParams struct {
	SkuID int32 `json:"sku_id"`
	Stock int32 `json:"stock"`
}

func (q *Queries) UpdateSkuStock(ctx context.Context, arg UpdateSkuStockParams) error {
	_, err := q.db.ExecContext(ctx, updateSkuStock, arg.SkuID, arg.Stock)
	return err
}
